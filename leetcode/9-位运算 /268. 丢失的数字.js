/**
 * @param {number[]} nums
 * @return {number}
 */

// 位运算
// 思路：相同的数异或为0
/**
   数组 nums 中有 n 个数，在这 n 个数的后面添加从 0 到 n 的每个整数，则添加了 n+1 个整数，共有 2n+1 个整数。
   在 2n+1 个整数中，丢失的数字只在后面 n+1 个整数中出现一次，其余的数字在前面 n 个整数中（即数组中）和后面 n+1 个整数中各出现一次，即其余的数字都出现了两次。
   根据出现的次数的奇偶性，可以使用按位异或运算得到丢失的数字。按位异或运算 ⊕ 满足交换律和结合律，且对任意整数 x 都满足 x ^ x = 0 和 x ^ 0 = x。
   由于上述 2n+1 个整数中，丢失的数字出现了一次，其余的数字都出现了两次，因此对上述 2n+1 个整数进行按位异或运算，结果即为丢失的数字。
 */
// 时间复杂度O(n)，空间复杂度O(1)
var missingNumber = function (nums) {
    let res = 0
    for (let i = 0; i < nums.length; i++) {
        res ^= i ^ nums[i]
    }
    res ^= nums.length
    return res
};
// 方法1.排序：在循环数组，看后一个数是不是比前一个大1

// 方法2.哈希表：将数组中的元素插入哈希表，然后循环0～nums.length-1中的数是不是都在哈希表中

// 方法3.求和：0～nums.length-1求和减去nums中的和